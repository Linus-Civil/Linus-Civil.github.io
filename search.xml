<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker常用命令合集</title>
    <url>/Tools-of-Programming/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h1 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h1><ul>
<li>Docker：是一个开放平台，用于开发、打包、交付（shipping）、运行应用。Docker允许用户将基础设施中的应用单独分割出来，形成更小的颗粒，从而提高交付软件的速度</li>
<li>Container：容器，可理解应用运行的环境，与虚拟机不同的是，容器为保持文件体积较小，可以只包含应用运行所必须的依赖库</li>
<li>Image：容器的镜像文件，当镜像未运行时，可以对其进行分享，构建等操作；当镜像运行时，才会创造容器环境（container environment），即Container是镜像的运行环境，注意二者的区别</li>
<li>Docker Hub：公开的容器镜像仓库，可以在其他云服务提供商付费获取私人仓库</li>
<li>Docker Desktop：Docker的图形界面软件，可以在图形界面上对镜像及容器进行管理；对于支持WSL 2的Windows系统而言，可以选择WSL 2作为Docker Desktop的后端，相较于Windows Hyper-V后端性能更好</li>
</ul>
<h1 id="基础命令合集"><a href="#基础命令合集" class="headerlink" title="基础命令合集"></a>基础命令合集</h1><h2 id="Image相关命令"><a href="#Image相关命令" class="headerlink" title="Image相关命令"></a>Image相关命令</h2><ul>
<li><code>docker pull image_name:version</code> ：从Docker Hub拉取镜像</li>
<li><code>docker run image_name:version</code> ：运行镜像，镜像不存在则先下载镜像<ul>
<li><code>-d</code> ：分离模式，即返回信息只有容器的ID</li>
<li><code>--name container_name</code>：对创造的容器环境命名</li>
<li>每次运行此命令都会创造新的容器环境，不同的容器环境ID不同</li>
</ul>
</li>
<li><code>docker images</code>：查看本地所有镜像</li>
<li><code>docker rmi image_name</code>：移除镜像</li>
</ul>
<h2 id="Container相关命令"><a href="#Container相关命令" class="headerlink" title="Container相关命令"></a>Container相关命令</h2><ul>
<li><code>docker ps</code> ：查看正在运行的容器<ul>
<li><code>-a</code>：此参数同时显示未运行的容器</li>
</ul>
</li>
<li><code>docker start container_ID</code>：重启容器，此命令不会创造新容器，注意与<code>docker run</code>区分</li>
<li><code>docker stop container_ID</code>：停止正在运行的容器</li>
<li><code>docker logs container_ID</code>或者<code>docker logs container_NAMES</code>：查看容器日志<ul>
<li><code>-f</code>：日志流，即实时记录容器的日志并打印至命令行</li>
<li><code>| tail</code>：查看尾部几条日志</li>
</ul>
</li>
<li><code>docker exec -it container_ID /bin/bash</code>或者<code>docker exec -it container_NAMES /bin/bash</code>：进入容器的命令行环境<ul>
<li><code>exit</code>：容器内部的命令行环境中输入此命令可返回<code>localhost</code>的命令行环境</li>
</ul>
</li>
<li><code>docker rm container_ID</code>：移除容器</li>
</ul>
<h1 id="高级命令合集"><a href="#高级命令合集" class="headerlink" title="高级命令合集"></a>高级命令合集</h1><h2 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h2><ul>
<li><code>docker run -p localhost_port:container_port</code>：以此命令运行容器后，本地应用可基于<code>localhost:localhost_port</code>端口与容器进行通信</li>
</ul>
<h2 id="Docker-Network"><a href="#Docker-Network" class="headerlink" title="Docker Network"></a>Docker Network</h2><p>Docker Network：可以让同一网络下的容器之间依据容器名进行通信</p>
<ul>
<li><code>docker network create net_name</code>：创建docker network</li>
<li><code>docker network ls</code>：查看所有docker network</li>
<li><code>docker run -e XXX=xxx -e YYY=yyy --net net_name image_name</code>：指定容器运行时的环境变量和network</li>
</ul>
<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>Docker Compose：一次性运行多个容器，而不是在命令行中一条条开启运行。实现原理是将多条命令映射成结构化文件</p>
<ul>
<li><code>docker-compose -f filename.yaml up</code>：运行结构化文件中设定的所有容器，并且这些容器都运行在同一network中</li>
<li><code>docker-compose -f filename.yaml down</code>：暂停结构化文件中设定的所有容器，并移除它们及其所在的network，这样也会移除数据，无法保证数据持久化</li>
</ul>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile：依据结构化文件<code>Dockerfile</code>构建自己的Docker镜像，即将自己编写的代码程序打包至已存在镜像中，打包需要基于某个base镜像，注意名字必须为Dockerfile</p>
<ul>
<li><code>docker build -t image_name:tag .</code>：构建自己的镜像，后面的<code>.</code>为<code>Dockerfile</code>文件所在的路径<ul>
<li>每次修改了dockerfile，都必须重新构建镜像</li>
</ul>
</li>
</ul>
<h2 id="Docker-Volumes"><a href="#Docker-Volumes" class="headerlink" title="Docker Volumes"></a>Docker Volumes</h2><p>Docker Volumes：于数据的长久保存，容器运行时数据储存在虚拟的文件系统中，每次重启容器文件会消失。因此通过将主机文件系统与虚拟文件系统挂载，所有文件将拷贝至主机文件系统，即可实现数据的持久化。</p>
<ul>
<li><code>docker run -v name:virtualdirectory</code>最推荐的挂载形式，只需为本地文件目录指定一个名字，具体路径由Docker决定，同样也可在docker compose中完成。<ul>
<li><code>C:\ProgramData\docker\volumes</code>：Windows系统默认的本地挂载路径</li>
<li><code>/var/lib/docker/volumes</code>：Linux系统默认的本地挂载路径</li>
<li><code>/var/lib/docker/volumes</code>：Mac系统默认的本地挂载路径</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Tools of Programming</category>
      </categories>
      <tags>
        <tag>Commands Collection</tag>
        <tag>Development &amp; Deployment</tag>
      </tags>
  </entry>
  <entry>
    <title>git简明教程</title>
    <url>/Tools-of-Programming/git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统，此文章简述了Git的基本原理、代码版本控制、GitHub联动（远程仓库）、分支管理以及标签管理等内容。</p>
<p>Git安装后需要通过以下命令配置用户名和邮箱，被用于远程仓库记录commits的相关信息，即用于查询哪次提交是谁完成的，配置的用户名和邮箱<strong>不会用于</strong>push代码到远程仓库时的身份验证。 <code>--global</code>参数表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Git跟踪代码仓库（Repository）中每个文件的改动，并基于改动提交的时间线形成日志（Log），后续便可根据相应的版本号进行版本回滚等操作。</p>
<span id="more"></span>

<h3 id="仓库建立"><a href="#仓库建立" class="headerlink" title="仓库建立"></a>仓库建立</h3><p>本地的代码仓库来源有两种：</p>
<ul>
<li>通过<code>git init</code>命令将本地某个文件夹变成Git可以管理的仓库</li>
<li>通过<code>git clone</code>命令将某个远程仓库克隆至本地，生成项目同名文件夹<br>基于Git的版本库文件夹下，具有<code>.git</code>子文件夹，这个文件夹是用来跟踪管理代码版本的</li>
</ul>
<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><p><img src="/Tools-of-Programming/git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/git_theory.png"></p>
<p>上图展示了Git管理下本地的三个工作区，包含代码库（Repository）的文件夹可以理解成工作目录(Working directory)，同时此文件夹下还具有一个暂存区（Stage）。当文件夹内出现新文件时，此文件会被标记为<strong>Untracked</strong>，表明此文件未被Git跟踪，即此文件未被包含至代码库内。对于本身就包含于代码库的文件，在其未修改时是<strong>Unmodify</strong>状态，修改后为<strong>Modified</strong>的状态。如果我们希望Git记录修改以及新增的内容，就可以先通过<code>git add [filename]</code>命令将其加入暂存区，此时改动文件被标记为<code>Staged</code>的状态。随后通过<code>git commit -m &quot;message&quot;</code>命令将改动内容提交到代码库，<code>-m</code>参数是添加此提交的注释信息。每次commit对应一个十六进制的<code>commit id</code>（版本号）。</p>
<p>常用的命令还包括以下几条：</p>
<ul>
<li><code>git status</code>查看当前目录下文件状态</li>
<li><code>git log</code>查看commit历史的时间线，版本回滚会导致时间线也回溯</li>
<li><code>git reflog</code>查看所有的命令，可以用来查询发生于回滚版本后的<code>commit id</code></li>
</ul>
<hr>
<h2 id="代码版本控制"><a href="#代码版本控制" class="headerlink" title="代码版本控制"></a>代码版本控制</h2><h3 id="版本回滚或回调"><a href="#版本回滚或回调" class="headerlink" title="版本回滚或回调"></a>版本回滚或回调</h3><p>所谓代码版本控制，即将代码库的版本根据需求变成对应<code>commit id</code>的版本，即对代码库版本进行回滚或者回调。下面是版本控制的常用命令，<code>HEAD</code>是当前分支当前版本的指针。</p>
<ul>
<li><code>git reset --hard HEAD^</code> 将当前版本回滚至上一个版本，<code>^</code>的数量表示回滚的数量，如果回滚的版本数太多，可以写成 <code>HEAD~100</code></li>
<li><code>git reset --hard id</code>将代码库改动至指定版本，版本号可以通过上述的<code>git log</code>和<code>git reflog</code>查询</li>
</ul>
<h3 id="单文件回滚"><a href="#单文件回滚" class="headerlink" title="单文件回滚"></a>单文件回滚</h3><p>上面叙述了如何在不同版本的代码库中进行切换，实际使用中还会涉及到单个文件的回滚，即撤销对某个文件的修改。下面分三种情况讨论如何撤销单个文件的修改：</p>
<ol>
<li>修改的文件处于<strong>Modified</strong>的状态，即还未将修改加入暂存区，使用<code> git checkout -- [filename]</code>命令撤销修改，此时文件变成和版本库一样，此命令本质是将版本库中记录的文件替换工作区中的对应文件。</li>
<li>修改的文件处于<strong>Staged</strong>的状态，即修改已经放入了暂存区，使用<code> git reset HEAD [filename]</code>将暂存区的修改退回工作区，然后使用<code> git checkout -- [filename]</code>丢弃工作区的修改。</li>
<li>如果文件的修改commit到了本地代码库，形成了新的代码版本，可以对版本进行回滚。</li>
</ol>
<h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><p>在工作目录使用文件管理器删除后，如果希望将代码库中对应的文件也删除，可以先通过<code> git rm  [filename]</code>删除，然后<code>git commit</code>提交；如果文件是误删，可以通过<code>git checkout -- [filename]</code>将文件恢复</p>
<hr>
<h2 id="GitHub联动"><a href="#GitHub联动" class="headerlink" title="GitHub联动"></a>GitHub联动</h2><p><strong>分布式</strong>版本控制系统Git中的分布式意味着项目中的所有开发人员都具有完整的版本库，但是通常需要某台中央服务器充当代码交换的作用，在其中建立远程代码库。本文以GitHub为例讲述本地仓库与远程仓库的联动，其他平台也是同理。既然本地仓库要与远程仓库联动，那么就需要在建立远程仓库与本地仓库的链接。通俗来说，当我们使用<code>git push</code>命令时，本地仓库需要知道push到哪个远程仓库。</p>
<ol>
<li>如果本地仓库是通过<code>git init</code>创建的，可以通过<code>git remote add origin git@github.com:username/reponame.git</code>命令将本地仓库与远程新建空仓库建立链接。 远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的 。随后使用<code>git push -u origin master</code>将本地的master分支推送到远程。 <code>-u</code>参数，会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令 。解绑链接通过<code>git remote rm origin</code>命令。</li>
<li>如果通过<code>git clone</code>创建的本地仓库，则本地仓库与远程仓库之间的链接是自动建立的。</li>
</ol>
<p>建立连接后，可以通过<code>git remote -v</code>查看远程仓库的信息。</p>
<h3 id="参与开源项目"><a href="#参与开源项目" class="headerlink" title="参与开源项目"></a>参与开源项目</h3><p>通常上述的push操作只能推送修改到自己的账号下，也就是将本地生成的SSH公钥添加至GitHub账号中。而通常的开源项目，核心外的开发人员通常不具备推送权限，因此可以通过以下流程参与开源项目：</p>
<ol>
<li>Fork别人的开源项目，就在自己的账号下克隆了一个同样的仓库</li>
<li>从自己的账号下的项目仓库克隆到本地</li>
<li>本地修改，推送到自己的仓库</li>
<li>发起Pull Request（PR）</li>
<li>等待对方接收合并或者拒绝</li>
</ol>
<hr>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>类似于平行宇宙，建立新分支意味着我们从某次commit后开启另一条提交时间线，此时间线与原始的提交时间线中的修改互不干扰。开发中新分支具体用途是用来测试不稳定的feature或者修改原始分支中的Bug。前文提到HEAD指向<strong>master</strong>分支，<strong>master</strong>指向当前版本的代码库。</p>
<p>创立新分支本质上是创立了一个新的分支指针指向当前版本的代码库，而切换分支是更改HEAD指向，因此每次改动的commit都会提交到HEAD所指的当前分支中。常用命令如下：</p>
<ul>
<li><code>git checkout -b dev</code>创建<code>dev</code>分支并且切换到<code>dev</code>分支</li>
<li><code>git branch dev</code>创建<code>dev</code>分支</li>
<li><code>git checkout dev</code>切换到<code>dev</code>分支</li>
<li><code>git branch</code>查看当前分支</li>
<li><code>git merge dev</code> 把<code>dev</code>分支的工作成果合并到<code>master</code>分支上 ，默认<code>Fast forward</code>模式合并</li>
<li><code>git branch -d dev</code>删除<code>dev</code>分支</li>
</ul>
<p>值得注意的是，分支合并时，如果不同分支中的同一文件的修改不同，那么合并会发生<strong>冲突（Merge conflict in filename）</strong>。冲突的修改方式为将不同分支中冲突的文件内容修改一致，然后再通过<code>git add</code>和<code>git commit</code>合并。</p>
<p>默认合并模式下， 删除分支后，会丢掉分支信息（失去合并历史） 。如果需要保留分支合并前的信息，可以禁用<code>Fast forward</code>模式，即使用<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>合并，会对分支合并前形成快照，即可以通过<code>git log --graph --pretty=oneline --abbrev-commit</code>命令以图的形式查看到合并历史。</p>
<h3 id="多人开发"><a href="#多人开发" class="headerlink" title="多人开发"></a>多人开发</h3><p> 在实际开发中，远程库通常具有<code>dev</code>和<code>master</code>两个分支。日常的新功能尝试都会在<code>dev</code>分支中进行，而<code>master</code>分支通常用来发布稳定的新版本，发布时将<code>dev</code>合并至<code>master</code>分支。每位开发员都可以拥有自己的独立开发分支， 时不时地往<code>dev</code>分支上合并就可以了 。</p>
<p>通常开发中远程仓库的分支管理涉及到以下问题：</p>
<ol>
<li>基于<code>master</code>发布的版本存在Bug，需要紧急修复，但自己目前在其他分支上的工作还没有提交。可以通过<code>git stash</code>将当前的工作现场保存，后续恢复现场继续工作。<ul>
<li><code>git stash list</code>查看所有保存的工作现场</li>
<li><code>git stash pop </code> 恢复现场、同时把stash内容删除</li>
<li><code>git stash apply</code>恢复 ， <code>git stash drop</code>删除 stash内容</li>
<li>如果修复的Bug在其他分支上也存在，可以通过<code>git cherry-pick id</code> 复制一个特定的提交到当前分支</li>
</ul>
</li>
<li>某个分支被开发出来后，还未被合并就要被删除，需要通过<code>git branch -D name</code>强行删除。</li>
<li><code>git push origin name</code>推送远程仓库时，需要指定本地分支名字， 这样，Git就会把该分支推送到远程库对应的远程分支上 。</li>
<li>从远程仓库克隆时，只能看到<code>master</code>分支， 要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地 <code>git checkout -b dev origin/dev</code>。</li>
<li>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建， <code>git branch --set-upstream-to=origin/dev dev</code>指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接 。</li>
<li>如果向远程仓库推送发生了冲突，即本地修改的文件与远程仓库中对应文件的修改存在冲突，可以 先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送 。本质上是将本地的代码库进行更新，然后合并本地的修改。</li>
<li><code>git pull</code>本质是更新本地代码库，在提交历史上会形成分叉，看起来类似分支合并。使用<code>git rebase</code> 把分叉的提交历史“整理”成一条直线，看上去更直观 。</li>
</ol>
<hr>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>标签管理就是对十六进制的<code>commit id</code>添加一个别名，具体操作如下：</p>
<ol>
<li>切换到需要打标签的分支</li>
<li><code>git tag [name] </code>就可以打一个新标签</li>
</ol>
<p> 值得注意的是标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 另外一些常用命令如下：</p>
<ul>
<li><code>git tag</code>查看所有标签，标签展示按照字母排序</li>
<li><code>git tag &lt;tagname&gt; </code> id<code>对指定的版本打标签，也可以使用</code>-m&#96;参数添加信息</li>
<li><code>git show &lt;tagname&gt; </code>可以查看标签的具体说明</li>
<li><code>git tag -d &lt;tagname&gt; </code>删除某标签</li>
<li><code>git push origin &lt;tagname&gt; </code>推送标签到远程</li>
<li><code>git push origin --tags</code> 一次性推送全部尚未推送到远程的本地标签 </li>
<li><code>git tag -d &lt;tagname&gt; </code>结合<code>git push origin :refs/tags/&lt;tagname&gt; </code>删除远程标签</li>
</ul>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 廖雪峰，Git教程，<a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>
<p>[2] Scott Chacon，Pro Git，<a href="http://iissnan.com/progit/">http://iissnan.com/progit/</a></p>
]]></content>
      <categories>
        <category>Tools of Programming</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
        <tag>Version control</tag>
      </tags>
  </entry>
</search>
