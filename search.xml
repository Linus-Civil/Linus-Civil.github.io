<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git简明教程</title>
    <url>/Tools-of-Programming/git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统，此文章简述了Git的基本原理、代码版本控制、GitHub联动（远程仓库）、分支管理以及标签管理等内容。</p>
<p>Git安装后需要通过以下命令配置用户名和邮箱，被用于远程仓库记录commits的相关信息，即用于查询哪次提交是谁完成的，配置的用户名和邮箱<strong>不会用于</strong>push代码到远程仓库时的身份验证。 <code>--global</code>参数表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Git跟踪代码仓库（Repository）中每个文件的改动，并基于改动提交的时间线形成日志（Log），后续便可根据相应的版本号进行版本回滚等操作。</p>
<span id="more"></span>

<h3 id="仓库建立"><a href="#仓库建立" class="headerlink" title="仓库建立"></a>仓库建立</h3><p>本地的代码仓库来源有两种：</p>
<ul>
<li>通过<code>git init</code>命令将本地某个文件夹变成Git可以管理的仓库</li>
<li>通过<code>git clone</code>命令将某个远程仓库克隆至本地，生成项目同名文件夹<br>基于Git的版本库文件夹下，具有<code>.git</code>子文件夹，这个文件夹是用来跟踪管理代码版本的</li>
</ul>
<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><p><img src="/Tools-of-Programming/git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/git_theory.png"></p>
<p>上图展示了Git管理下本地的三个工作区，包含代码库（Repository）的文件夹可以理解成工作目录(Working directory)，同时此文件夹下还具有一个暂存区（Stage）。当文件夹内出现新文件时，此文件会被标记为<strong>Untracked</strong>，表明此文件未被Git跟踪，即此文件未被包含至代码库内。对于本身就包含于代码库的文件，在其未修改时是<strong>Unmodify</strong>状态，修改后为<strong>Modified</strong>的状态。如果我们希望Git记录修改以及新增的内容，就可以先通过<code>git add [filename]</code>命令将其加入暂存区，此时改动文件被标记为<code>Staged</code>的状态。随后通过<code>git commit -m &quot;message&quot;</code>命令将改动内容提交到代码库，<code>-m</code>参数是添加此提交的注释信息。每次commit对应一个十六进制的<code>commit id</code>（版本号）。</p>
<p>常用的命令还包括以下几条：</p>
<ul>
<li><code>git status</code>查看当前目录下文件状态</li>
<li><code>git log</code>查看commit历史的时间线，版本回滚会导致时间线也回溯</li>
<li><code>git reflog</code>查看所有的命令，可以用来查询发生于回滚版本后的<code>commit id</code></li>
</ul>
<hr>
<h2 id="代码版本控制"><a href="#代码版本控制" class="headerlink" title="代码版本控制"></a>代码版本控制</h2><h3 id="版本回滚或回调"><a href="#版本回滚或回调" class="headerlink" title="版本回滚或回调"></a>版本回滚或回调</h3><p>所谓代码版本控制，即将代码库的版本根据需求变成对应<code>commit id</code>的版本，即对代码库版本进行回滚或者回调。下面是版本控制的常用命令，<code>HEAD</code>是当前分支当前版本的指针。</p>
<ul>
<li><code>git reset --hard HEAD^</code> 将当前版本回滚至上一个版本，<code>^</code>的数量表示回滚的数量，如果回滚的版本数太多，可以写成 <code>HEAD~100</code></li>
<li><code>git reset --hard id</code>将代码库改动至指定版本，版本号可以通过上述的<code>git log</code>和<code>git reflog</code>查询</li>
</ul>
<h3 id="单文件回滚"><a href="#单文件回滚" class="headerlink" title="单文件回滚"></a>单文件回滚</h3><p>上面叙述了如何在不同版本的代码库中进行切换，实际使用中还会涉及到单个文件的回滚，即撤销对某个文件的修改。下面分三种情况讨论如何撤销单个文件的修改：</p>
<ol>
<li>修改的文件处于<strong>Modified</strong>的状态，即还未将修改加入暂存区，使用<code> git checkout -- [filename]</code>命令撤销修改，此时文件变成和版本库一样，此命令本质是将版本库中记录的文件替换工作区中的对应文件。</li>
<li>修改的文件处于<strong>Staged</strong>的状态，即修改已经放入了暂存区，使用<code> git reset HEAD [filename]</code>将暂存区的修改退回工作区，然后使用<code> git checkout -- [filename]</code>丢弃工作区的修改。</li>
<li>如果文件的修改commit到了本地代码库，形成了新的代码版本，可以对版本进行回滚。</li>
</ol>
<h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><p>在工作目录使用文件管理器删除后，如果希望将代码库中对应的文件也删除，可以先通过<code> git rm  [filename]</code>删除，然后<code>git commit</code>提交；如果文件是误删，可以通过<code>git checkout -- [filename]</code>将文件恢复</p>
<hr>
<h2 id="GitHub联动"><a href="#GitHub联动" class="headerlink" title="GitHub联动"></a>GitHub联动</h2><p><strong>分布式</strong>版本控制系统Git中的分布式意味着项目中的所有开发人员都具有完整的版本库，但是通常需要某台中央服务器充当代码交换的作用，在其中建立远程代码库。本文以GitHub为例讲述本地仓库与远程仓库的联动，其他平台也是同理。既然本地仓库要与远程仓库联动，那么就需要在建立远程仓库与本地仓库的链接。通俗来说，当我们使用<code>git push</code>命令时，本地仓库需要知道push到哪个远程仓库。</p>
<ol>
<li>如果本地仓库是通过<code>git init</code>创建的，可以通过<code>git remote add origin git@github.com:username/reponame.git</code>命令将本地仓库与远程新建空仓库建立链接。 远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的 。随后使用<code>git push -u origin master</code>将本地的master分支推送到远程。 <code>-u</code>参数，会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令 。解绑链接通过<code>git remote rm origin</code>命令。</li>
<li>如果通过<code>git clone</code>创建的本地仓库，则本地仓库与远程仓库之间的链接是自动建立的。</li>
</ol>
<p>建立连接后，可以通过<code>git remote -v</code>查看远程仓库的信息。</p>
<h3 id="参与开源项目"><a href="#参与开源项目" class="headerlink" title="参与开源项目"></a>参与开源项目</h3><p>通常上述的push操作只能推送修改到自己的账号下，也就是将本地生成的SSH公钥添加至GitHub账号中。而通常的开源项目，核心外的开发人员通常不具备推送权限，因此可以通过以下流程参与开源项目：</p>
<ol>
<li>Fork别人的开源项目，就在自己的账号下克隆了一个同样的仓库</li>
<li>从自己的账号下的项目仓库克隆到本地</li>
<li>本地修改，推送到自己的仓库</li>
<li>发起Pull Request（PR）</li>
<li>等待对方接收合并或者拒绝</li>
</ol>
<hr>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>类似于平行宇宙，建立新分支意味着我们从某次commit后开启另一条提交时间线，此时间线与原始的提交时间线中的修改互不干扰。开发中新分支具体用途是用来测试不稳定的feature或者修改原始分支中的Bug。前文提到HEAD指向<strong>master</strong>分支，<strong>master</strong>指向当前版本的代码库。</p>
<p>创立新分支本质上是创立了一个新的分支指针指向当前版本的代码库，而切换分支是更改HEAD指向，因此每次改动的commit都会提交到HEAD所指的当前分支中。常用命令如下：</p>
<ul>
<li><code>git checkout -b dev</code>创建<code>dev</code>分支并且切换到<code>dev</code>分支</li>
<li><code>git branch dev</code>创建<code>dev</code>分支</li>
<li><code>git checkout dev</code>切换到<code>dev</code>分支</li>
<li><code>git branch</code>查看当前分支</li>
<li><code>git merge dev</code> 把<code>dev</code>分支的工作成果合并到<code>master</code>分支上 ，默认<code>Fast forward</code>模式合并</li>
<li><code>git branch -d dev</code>删除<code>dev</code>分支</li>
</ul>
<p>值得注意的是，分支合并时，如果不同分支中的同一文件的修改不同，那么合并会发生<strong>冲突（Merge conflict in filename）</strong>。冲突的修改方式为将不同分支中冲突的文件内容修改一致，然后再通过<code>git add</code>和<code>git commit</code>合并。</p>
<p>默认合并模式下， 删除分支后，会丢掉分支信息（失去合并历史） 。如果需要保留分支合并前的信息，可以禁用<code>Fast forward</code>模式，即使用<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>合并，会对分支合并前形成快照，即可以通过<code>git log --graph --pretty=oneline --abbrev-commit</code>命令以图的形式查看到合并历史。</p>
<h3 id="多人开发"><a href="#多人开发" class="headerlink" title="多人开发"></a>多人开发</h3><p> 在实际开发中，远程库通常具有<code>dev</code>和<code>master</code>两个分支。日常的新功能尝试都会在<code>dev</code>分支中进行，而<code>master</code>分支通常用来发布稳定的新版本，发布时将<code>dev</code>合并至<code>master</code>分支。每位开发员都可以拥有自己的独立开发分支， 时不时地往<code>dev</code>分支上合并就可以了 。</p>
<p>通常开发中远程仓库的分支管理涉及到以下问题：</p>
<ol>
<li>基于<code>master</code>发布的版本存在Bug，需要紧急修复，但自己目前在其他分支上的工作还没有提交。可以通过<code>git stash</code>将当前的工作现场保存，后续恢复现场继续工作。<ul>
<li><code>git stash list</code>查看所有保存的工作现场</li>
<li><code>git stash pop </code> 恢复现场、同时把stash内容删除</li>
<li><code>git stash apply</code>恢复 ， <code>git stash drop</code>删除 stash内容</li>
<li>如果修复的Bug在其他分支上也存在，可以通过<code>git cherry-pick id</code> 复制一个特定的提交到当前分支</li>
</ul>
</li>
<li>某个分支被开发出来后，还未被合并就要被删除，需要通过<code>git branch -D name</code>强行删除。</li>
<li><code>git push origin name</code>推送远程仓库时，需要指定本地分支名字， 这样，Git就会把该分支推送到远程库对应的远程分支上 。</li>
<li>从远程仓库克隆时，只能看到<code>master</code>分支， 要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地 <code>git checkout -b dev origin/dev</code>。</li>
<li>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建， <code>git branch --set-upstream-to=origin/dev dev</code>指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接 。</li>
<li>如果向远程仓库推送发生了冲突，即本地修改的文件与远程仓库中对应文件的修改存在冲突，可以 先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送 。本质上是将本地的代码库进行更新，然后合并本地的修改。</li>
<li><code>git pull</code>本质是更新本地代码库，在提交历史上会形成分叉，看起来类似分支合并。使用<code>git rebase</code> 把分叉的提交历史“整理”成一条直线，看上去更直观 。</li>
</ol>
<hr>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>标签管理就是对十六进制的<code>commit id</code>添加一个别名，具体操作如下：</p>
<ol>
<li>切换到需要打标签的分支</li>
<li><code>git tag [name] </code>就可以打一个新标签</li>
</ol>
<p> 值得注意的是标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 另外一些常用命令如下：</p>
<ul>
<li><code>git tag</code>查看所有标签，标签展示按照字母排序</li>
<li><code>git tag &lt;tagname&gt; </code> id<code>对指定的版本打标签，也可以使用</code>-m&#96;参数添加信息</li>
<li><code>git show &lt;tagname&gt; </code>可以查看标签的具体说明</li>
<li><code>git tag -d &lt;tagname&gt; </code>删除某标签</li>
<li><code>git push origin &lt;tagname&gt; </code>推送标签到远程</li>
<li><code>git push origin --tags</code> 一次性推送全部尚未推送到远程的本地标签 </li>
<li><code>git tag -d &lt;tagname&gt; </code>结合<code>git push origin :refs/tags/&lt;tagname&gt; </code>删除远程标签</li>
</ul>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 廖雪峰，Git教程，<a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>
<p>[2] Scott Chacon，Pro Git，<a href="http://iissnan.com/progit/">http://iissnan.com/progit/</a></p>
]]></content>
      <categories>
        <category>Tools of Programming</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
        <tag>Version control</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/uncategorized/test-1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/testmyweb/test/</url>
    <content><![CDATA[<p>1111</p>
]]></content>
      <categories>
        <category>testmyweb</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
